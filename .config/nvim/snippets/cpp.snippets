snippet fenwick
  template <class T>
  struct Fenwick {
      int n;
      vector<T> fw;
      vector<T> arr;

      Fenwick(int n) : n(n), fw(n + 1), arr(n + 1) {}

      void set(int i, T x) {
          add(i, x - arr[i]);
      }

      void add(int i, T x) {
          arr[i] += x;
          for (; i <= n; i += i & -i) fw[i] += x;
      }

      T sum(int i) {
          T ret = 0;
          for (; i > 0; i -= i & -i) ret += fw[i];
          return ret;
      }

      T sum(int l, int r) { return sum(r) - sum(l - 1); }
  };

snippet segtree
  template <class T, auto op, auto e>
  struct SegmentTree {
      int n;
      vector<T> a, t;

      SegmentTree(int n) : n(n), a(n + 1, e()), t(4 * n) {};
      SegmentTree(vector<T> a) : n(sz(a) - 1), a(a), t(4 * n) {};

      void build(int x, int tl, int tr) {
          if (tl == tr) {
              t[x] = a[tl];
              return;
          }
          int m = (tl + tr) / 2;
          build(x * 2, tl, m);
          build(x * 2 + 1, m + 1, tr);
          t[x] = op(t[x * 2], t[x * 2 + 1]);
      }

      void upd(int idx, T val, int x, int tl, int tr) {
          if (tl == tr) {
              t[x] = a[tl] = val;
              return;
          }
          int m = (tl + tr) / 2;
          if (idx <= m) upd(idx, val, x * 2, tl, m);
          else upd(idx, val, x * 2 + 1, m + 1, tr);
          t[x] = op(t[x * 2], t[x * 2 + 1]);
      }

      T query(int l, int r, int x, int tl, int tr) {
          if (tr < l || r < tl) return e();
          else if (l <= tl && tr <= r) return t[x];
          int m = (tl + tr) / 2;
          return op(query(l, r, x * 2, tl, m), query(l, r, x * 2 + 1, m + 1, tr));
      }

      void build() { build(1, 1, n); }
      void upd(int idx, T val) { upd(idx, val, 1, 1, n); }
      T query(int l, int r) { return query(l, r, 1, 1, n); }
  };

snippet modint
  template <int mod> struct mint {
      int v;
      explicit operator int() const { return v; } // explicit -> don't silently convert to int
      mint() : v(0) {}
      mint(ll _v) {
          v = _v % mod;
          if (v < 0) v += mod;
      }
      bool operator==(const mint &o) const { return v == o.v; }
      friend bool operator!=(const mint &a, const mint &b) { return !(a == b); }
      friend bool operator<(const mint &a, const mint &b) { return a.v < b.v; }
      friend istream &operator>>(istream &is, mint &a) {
          ll x;
          is >> x;
          a = mint(x);
          return is;
      }
      friend ostream &operator<<(ostream &os, mint a) {
          os << int(a);
          return os;
      }

      mint &operator+=(const mint &o) {
          if ((v += o.v) >= mod) v -= mod;
          return *this;
      }
      mint &operator-=(const mint &o) {
          if ((v -= o.v) < 0) v += mod;
          return *this;
      }
      mint &operator*=(const mint &o) {
          v = int((ll)v * o.v % mod);
          return *this;
      }
      mint &operator/=(const mint &o) { return (*this) *= inverse(o); }
      friend mint fpow(mint a, ll p) {
          mint ans = 1;
          assert(p >= 0);
          for (; p; p /= 2, a *= a)
              if (p & 1) ans *= a;
          return ans;
      }
      friend mint inverse(const mint &a) {
          assert(a.v != 0);
          return fpow(a, mod - 2);
      }

      mint operator-() const { return mint(-v); }
      mint &operator++() { return *this += 1; }
      mint &operator--() { return *this -= 1; }
      mint operator++(int) { mint ret = *this; ++*this; return ret; }
      mint operator--(int) { mint ret = *this; --*this; return ret; }
      friend mint operator+(mint a, const mint &b) { return a += b; }
      friend mint operator-(mint a, const mint &b) { return a -= b; }
      friend mint operator*(mint a, const mint &b) { return a *= b; }
      friend mint operator/(mint a, const mint &b) { return a /= b; }
  };
  using mi = mint<M>;
  using vmi = vector<mi>;

snippet fft
  using cd = complex<double>;
  const double PI = acos(-1);

  void fft(vector<cd>& a, bool invert = false) {
      int n = a.size();

      for (int i = 1, j = 0; i < n; i++) {
          int bit = n >> 1;
          for (; j & bit; bit >>= 1) j ^= bit;
          j ^= bit;
          if (i < j) swap(a[i], a[j]);
      }

      for (int len = 2; len <= n; len <<= 1) {
          double ang = 2 * PI / len * (invert ? -1 : 1);
          cd wlen(cos(ang), sin(ang));
          for (int i = 0; i < n; i += len) {
              cd w(1);
              for (int j = 0; j < len / 2; j++) {
                  cd u = a[i + j], v = a[i + j + len / 2] * w;
                  a[i + j] = u + v;
                  a[i + j + len / 2] = u - v;
                  w *= wlen;
              }
          }
      }

      if (invert) {
          for (cd & x : a) x /= n;
      }
  }

  template <class T>
  vector<T> convolution_fft(vector<T> a, vector<T> b) {
      if (a.empty() || b.empty()) return {};
      int x = sz(a) + sz(b) - 1;
      int L = 32 - __builtin_clz(x), n = 1 << L;
      a.resize(n);
      b.resize(n);
      fft(a);
      fft(b);
      for (int i = 0; i < n; i++) a[i] *= b[i];
      fft(a, true);
      a.resize(x);
      return a;
  }

snippet ntt
  const mi ROOT = 3; // mod 998244353
  const int LN = 23; // 119 * 2^23 + 1
  const int Z = 1 << LN;
  vmi root(Z);

  void fft(vector<mi>& a, bool invert = false) {
      static const bool initialized = []{
          mi u = fpow(ROOT, (M - 1) >> LN);
          root[0] = 1;
          rep (i, 1, Z - 1) root[i] = u * root[i - 1];
          return true;
      }();

      int n = a.size();

      for (int i = 1, j = 0; i < n; i++) {
          int bit = n >> 1;
          for (; j & bit; bit >>= 1) j ^= bit;
          j ^= bit;
          if (i < j) swap(a[i], a[j]);
      }

      for (int len = 2; len <= n; len <<= 1) {
          mi wlen = invert ? root[Z - Z / len] : root[Z / len];
          for (int i = 0; i < n; i += len) {
              mi w = 1;
              for (int j = 0; j < len / 2; j++) {
                  mi u = a[i + j], v = a[i + j + len / 2] * w;
                  a[i + j] = u + v;
                  a[i + j + len / 2] = u - v;
                  w *= wlen;
              }
          }
      }

      if (invert) {
          mi inv = inverse(mi(n));
          for (auto &x : a) x *= inv;
      }
  }

  vmi convolution(vmi a, vmi b) {
      if (a.empty() || b.empty()) return {};
      int x = sz(a) + sz(b) - 1;
      int L = 32 - __builtin_clz(x), n = 1 << L;
      a.resize(n);
      b.resize(n);
      fft(a);
      fft(b);
      for (int i = 0; i < n; i++) a[i] *= b[i];
      fft(a, true);
      a.resize(x);
      return a;
  }

snippet fps
  struct FPS : vmi {
      using vmi::vector;

      // 998244353 = 119 * 2^23 + 1
      static const int K = 23, C = 119, R = 3;
      static mi w[K + 1], w_inv[K + 1];
      static bool init_NTT;

      void NTT(bool invert) {
          if (!init_NTT) {
              w[K] = fpow(mi(R), C);
              for (int i = K - 1; i >= 0; i--) w[i] = w[i + 1] * w[i + 1];
              for (int i = 0; i <= K; i++) w_inv[i] = inverse(w[i]);
              init_NTT = true;
          }

          int n = this->size();
          FPS tmp = *this;

          for (int i = 0; i < n; i++) {
              int idx = 0;
              int lgn = __lg(n);
              for (int j = lgn - 1; j >= 0; j--)
                  idx = (idx << 1) | ((i >> (lgn - j - 1)) & 1);
              (*this)[idx] = tmp[i];
          }

          for (int l = 2; l <= n; l <<= 1) {
              mi w_l = invert ? w_inv[__lg(l)] : w[__lg(l)];
              for (int i = 0; i < n; i += l) {
                  mi w_cur = 1;
                  for (int j = 0; j < (l >> 1); j++) {
                      mi t = (*this)[i + j + (l >> 1)] * w_cur;
                      (*this)[i + j + (l >> 1)] = (*this)[i + j] - t;
                      (*this)[i + j] = (*this)[i + j] + t;
                      w_cur *= w_l;
                  }
              }
          }

          if (invert) {
              mi inv_n = inverse(mi(n));
              for (int i = 0; i < n; i++) (*this)[i] *= inv_n;
          }
      }

      FPS& operator+=(FPS &b) {
          if (this->size() < b.size()) this->resize(b.size(), 0);
          for (int i = 0; i < (int)b.size(); i++) (*this)[i] += b[i];
          return *this;
      }

      FPS& operator-=(FPS &b) {
          if (this->size() < b.size()) this->resize(b.size(), 0);
          for (int i = 0; i < (int)b.size(); i++) (*this)[i] -= b[i];
          return *this;
      }

      FPS& operator*=(FPS b) {
          int mxSz = (int)this->size() + (int)b.size() - 1;
          int n = (mxSz == 1) ? 2 : (1 << (__lg(mxSz - 1) + 1));

          this->resize(n, 0);
          b.resize(n, 0);

          this->NTT(false);
          b.NTT(false);
          for (int i = 0; i < n; i++) (*this)[i] *= b[i];
          this->NTT(true);

          this->resize(mxSz);
          return *this;
      }

      FPS& operator*=(mi b) {
          for (int i = 0; i < (int)this->size(); i++) (*this)[i] *= b;
          return *this;
      }

      FPS integral() {
          vmi Inv(this->size() + 1);
          Inv[1] = 1;
          for (int i = 2; i < (int)Inv.size(); i++)
              Inv[i] = mi(M - M / i) * Inv[M % i];

          FPS Q(this->size() + 1, 0);
          for (int i = 0; i < (int)this->size(); i++)
              Q[i + 1] = (*this)[i] * Inv[i + 1];
          return Q;
      }

      FPS derivative() {
          assert(!this->empty());
          FPS Q((int)this->size() - 1);
          for (int i = 1; i < (int)this->size(); i++)
              Q[i - 1] = (*this)[i] * i;
          return Q;
      }

      FPS inv(int k) {
          assert(!this->empty() && (*this)[0] != 0);
          FPS Q(1, inverse((*this)[0]));
          for (int i = 1; (1 << (i - 1)) < k; i++) {
              FPS P = *this;
              P.resize(1 << i, 0);
              Q = Q * (FPS(1, 2) - P * Q);
              Q.resize(1 << i, 0);
          }
          Q.resize(k);
          return Q;
      }

      FPS log(int k) {
          assert(!this->empty() && (*this)[0] == 1);
          FPS Q = (this->derivative() * this->inv(k));
          Q.resize(k - 1);
          return Q.integral();
      }

      FPS exp(int k) {
          assert(!this->empty() && (*this)[0] == 0);
          FPS Q(1, 1);
          for (int i = 1; (1 << (i - 1)) < k; i++) {
              FPS P = *this;
              P.resize(1 << i, 0);
              Q = Q * (FPS(1, 1) + P - Q.log(1 << i));
              Q.resize(1 << i, 0);
          }
          Q.resize(k);
          return Q;
      }

      FPS pow(long long idx, int k) {
          if (idx == 0) {
              FPS res(k, 0);
              res[0] = 1;
              return res;
          }
          for (int i = 0; i < (int)this->size() && (long long)i * idx < k; i++) {
              if ((*this)[i] != 0) {
                  mi inv = inverse((*this)[i]);
                  FPS Q((int)this->size() - i);
                  for (int j = i; j < (int)this->size(); j++)
                      Q[j - i] = (*this)[j] * inv;
                  Q = (Q.log(k) * idx).exp(k);

                  FPS res(k, 0);
                  mi pw = fpow((*this)[i], idx);
                  for (int j = 0; j + (long long)i * idx < k; j++)
                      res[j + i * idx] = Q[j] * pw;
                  return res;
              }
          }
          return FPS(k, 0);
      }

      friend FPS operator+(FPS a, FPS b) { return a += b; }
      friend FPS operator-(FPS a, FPS b) { return a -= b; }
      friend FPS operator*(FPS a, FPS b) { return a *= b; }
      friend FPS operator*(FPS a, mi b) { return a *= b; }
  };
  bool FPS::init_NTT = false;
  mi FPS::w[K + 1];
  mi FPS::w_inv[K + 1];

snippet bostanmori
  // find coefficient of x^n in O(d * log(d) * log(n)); Q[0] != 0
  mi bostan_mori(FPS P, FPS Q, ll n) {
      while (n > 0) {
          FPS Qm = Q;
          for (int i = 1; i < sz(Qm); i += 2)
              Qm[i] = -Qm[i];

          FPS PQ = P * Qm;
          FPS QQ = Q * Qm;

          FPS nP, nQ;
          for (int i = (n & 1); i < sz(PQ); i += 2)
              nP.pb(PQ[i]);
          for (int i = 0; i < sz(QQ); i += 2)
              nQ.pb(QQ[i]);

          P = nP;
          Q = nQ;
          n >>= 1;
      }
      return P[0] / Q[0];
  }

